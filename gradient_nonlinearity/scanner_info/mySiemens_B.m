function B = mySiemens_B(Alpha, Beta, L, A, F, R0, Gref)
% Compute the Bz generated by a Siemens gradient coil.
%
% B = mySiemens_B(Alpha, Beta, L, A, F, R0, Gref)
%
% -- Alpha & Beta: square matrix with the first nxn spherical
%    harmonic coefficients
% -- L, A, F: arrays containing the LAF coordinates of the
%    points for which the value of Bz is desired.
% -- R0, Gref: normalization constants.
%
% NOTE 1: this expects L,A,F and returns B in MILLIMETERS.
%                                             
% NOTE 2: Before, the spherical harmonics described the mapping from a
% point (L,A,F) to the Bz field generated by a particular gradient
% coil. At some point, Siemens switched to having the spherical
% harmonics describe the DEPARTURE FROM LINEARITY of the Bz field,
% which requires fewer expansion terms and is actually what we want
% for the displacements due to gradient nonlinearity warping.

% (mukundb)

% NOTE: Siemens-gradients want (X,Y,Z) to be (left,anterior,foot)
X =  L;
Y =  A;
Z =  F;

% Make sure X, Y, Z are all the same size
X+Y; 
Y+Z;

% Vectorize X, Y, Z; later on, reshape B
XYZsize = size(X);
X = X(:).';
Y = Y(:).';
Z = Z(:).';

% Convert from mm to m for Siemens
X = X/1000;
Y = Y/1000;
Z = Z/1000;

% Num expansion terms
nmax = size(Alpha,1)-1;

% Convert to spherical coords
X = X+0.0001; % hack to avoid singularities (R==0)
R = sqrt(X.^2+Y.^2+Z.^2);
Theta = acos(Z./R);
Phi = atan2(Y./R, X./R);

% Set up vandermonde matrix and coeffs vector
vdm = [];
coeffs = [];
counter = 0;
B = 0;
for n = 0:nmax
   P = siemens_legendre(n,cos(Theta)); % Siemens-specific
   F = (R/R0).^n;
   for m = 0:n
      F2 = Alpha(n+1,m+1)*cos(m*Phi)+Beta(n+1,m+1)*sin(m*Phi);
      B = B+F.*P(m+1,:).*F2;
     %if( abs(Alpha(n+1,m+1)) > sqrt(eps) )
     %  counter = counter + 1;
     %  vdm(:, counter) = F.*cos(m*Phi).*P(m+1,:)';
      % coeffs(counter) = Alpha(n+1,m+1);
     %end
    % 
    % if( abs(Beta(n+1,m+1)) > sqrt(eps) )
    %   counter = counter + 1;
    %   vdm(:, counter) = F.*sin(m*Phi).*P(m+1,:)';
    %   coeffs(counter) = Beta(n+1,m+1);
    % end
   
   end
end

% Multiply vandermonde matrix and coeffs vector
%coeffs = coeffs(:);
%B = vdm*coeffs;

% Convert to meters
B = B*R0;

% Convert from m to mm
B = B*1000;

% Reshape into original
B = reshape(B, XYZsize);




